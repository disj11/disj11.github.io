<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Life Log</title><link>https://disj11.github.io/posts/</link><description>Recent content in Posts on Life Log</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Tue, 10 Jan 2023 23:59:43 +0900</lastBuildDate><atom:link href="https://disj11.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Kotlin: Memory Efficient Iterable Data Processing with Sequences</title><link>https://disj11.github.io/memory-efficient-iterable-data-processing-with-sequences/</link><pubDate>Tue, 10 Jan 2023 23:59:43 +0900</pubDate><guid>https://disj11.github.io/memory-efficient-iterable-data-processing-with-sequences/</guid><description>
Kotlin provides extension functions for the Iterable interface, such as the filter function. Here is an example of using the filter function:
fun averageNonBlankLength(strings: List&amp;lt;String&amp;gt;): Double = strings .filter { it.isNotBlank() } .map(String::length) .sum() / strings.size.toDouble() It&amp;rsquo;s worth noting that the filter and map functions in Kotlin return new Lists, unlike their counterparts Stream.filter and Stream.map in Java, which return a Stream. In this example, two new intermediate lists are created in memory as the result of calling filter and map on the original list.</description></item><item><title>Nullable Receiver in Extension Functions of Kotlin</title><link>https://disj11.github.io/nullable-receiver-in-extension-functions-of-kotlin/</link><pubDate>Sun, 08 Jan 2023 21:22:27 +0900</pubDate><guid>https://disj11.github.io/nullable-receiver-in-extension-functions-of-kotlin/</guid><description>
The receiver object in extension functions allows null values because it is actually a parameter. At first glance, anObject.method() and anObject.extensionFunction() may look similar, but this is not the case. If anObject is null, the method() will never be called, but the extensionFunction() can still be called. Here is an example:
fun String?.extensionFunction() = this?.length fun main() { val str: String? = null println(str.extensionFunction()) // prints &amp;#39;null&amp;#39; } In this example, when using this inside an extension function, note that the safe call operator should be used.</description></item><item><title>Notes on Using Data Classes in Kotlin</title><link>https://disj11.github.io/notes-on-using-data-classes-in-kotlin/</link><pubDate>Sun, 08 Jan 2023 14:39:00 +0900</pubDate><guid>https://disj11.github.io/notes-on-using-data-classes-in-kotlin/</guid><description>
When using data classes in Kotlin, it is important to keep a few things in mind. Data classes automatically create a copy() function, which can be used to create a new instance of the class with modified property values. However, if a property of the class must maintain an invariant, this function may not behave as expected.
For example, consider the following Point class:
data class Point private constructor( val value: Int, ) { companion object { fun of(value: Int) = if (value &amp;lt; 0) { throw IllegalArgumentException(&amp;#34;The value argument should always be set to a positive value, but the current value is $value&amp;#34;) } else { Point(value) } } } The value property of the Point class is intended to be positive.</description></item><item><title>Introduction to SOLID Design Principles</title><link>https://disj11.github.io/introduction-to-solid-design-principles/</link><pubDate>Wed, 03 Nov 2021 21:21:49 +0900</pubDate><guid>https://disj11.github.io/introduction-to-solid-design-principles/</guid><description>
개요 # SOLID 란 Robert C.Martin 이 명명한 객체 지향 프로그래밍의 다섯 가지 설계 원칙이다. SOLID 는 다음을 의미한다. S - Single-responsibility Principle (SRP: 단일 책임 원칙) O - Open-closed Principle (OCP: 개방-폐쇄 원칙) L - Liskov</description></item><item><title>Http Client in Java</title><link>https://disj11.github.io/http-client-in-java/</link><pubDate>Tue, 02 Nov 2021 18:11:57 +0900</pubDate><guid>https://disj11.github.io/http-client-in-java/</guid><description>
개요 # 이전까지 자바에서 사용하던 HttpURLConnection 는 지원 수준이 너무 낮아 서드 파티 라이브러리인 Apache HttpClient, Jetty, 스프링의 RestTemplate 을 많이 사용하였다. 하지만 Java 11 에서 HTTP/2와 Web Socket 을</description></item><item><title>Number Formatter in Java</title><link>https://disj11.github.io/number-formatter-in-java/</link><pubDate>Mon, 01 Nov 2021 20:00:12 +0900</pubDate><guid>https://disj11.github.io/number-formatter-in-java/</guid><description>
개요 # DecimalFormat은 미리 정의된 포맷을 사용하여 10진수 문자열 표현을 형식화 할 수 있는 NumberFormat 의 하위 클래스이다. 역으로 문자열을 숫자로 구문 분석</description></item><item><title>An Introduction to Oauth2</title><link>https://disj11.github.io/an-introduction-to-oauth2/</link><pubDate>Fri, 22 Oct 2021 10:08:30 +0900</pubDate><guid>https://disj11.github.io/an-introduction-to-oauth2/</guid><description>
소개 # OAuth는 오픈 API의 인증(authentication)과 권한 부여(authorization)를 제공하기 위해 만들어진 프로토콜이다</description></item><item><title>Date Time Formatter in Java</title><link>https://disj11.github.io/date-time-formatter-in-java/</link><pubDate>Wed, 29 Sep 2021 19:33:31 +0900</pubDate><guid>https://disj11.github.io/date-time-formatter-in-java/</guid><description>
개요 # Java8 에서 추가된 DateTimeFormatter 클래스에 대해 알아보자. 미리 정의된 인스턴스 # DateTimeFormatter 에는 ISO 및 RFC 표준을 따라 정의되어 있는 날짜/시간 포맷을 제공한다. 예를들어 ISO_LOCAL_DATE 인스턴스</description></item></channel></rss>