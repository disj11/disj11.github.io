<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on</title><link>https://disj11.github.io/posts/</link><description>Recent content in Posts on</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Sun, 29 Dec 2024 21:36:18 +0900</lastBuildDate><atom:link href="https://disj11.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Hibernate Proxy 비정상 동작 사례 분석</title><link>https://disj11.github.io/inconsistent-hibernate-proxy-behavior-with-kotlin/</link><pubDate>Sun, 29 Dec 2024 21:36:18 +0900</pubDate><guid>https://disj11.github.io/inconsistent-hibernate-proxy-behavior-with-kotlin/</guid><description>
Kotlin 엔티티에서 동일 이름의 Getter 메서드로 인해 발생한 Hibernate Proxy의 비정상 동작 사례를 분석하고, 문제의 원인과 해결 방안을 제시합니다.</description></item><item><title>Ktlint: 기본 설정 변경 및 커스터마이징 가이드</title><link>https://disj11.github.io/editorconfig/</link><pubDate>Thu, 22 Feb 2024 20:46:04 +0900</pubDate><guid>https://disj11.github.io/editorconfig/</guid><description>
.editorconfig를 활용한 스타일 커스터마이징 방법을 알아봅니다. 특정 규칙 비활성화, IntelliJ 플러그인 사용법, 그리고 효율적인 코드 스타일 관리 팁을 제공합니다.</description></item><item><title>S3 Sink Connector Scheduled Rotation</title><link>https://disj11.github.io/s3-sink-connector-scheduled-rotation/</link><pubDate>Wed, 10 Jan 2024 16:42:15 +0900</pubDate><guid>https://disj11.github.io/s3-sink-connector-scheduled-rotation/</guid><description>
S3 Sink Connector에서 파일 로테이션을 설정하는 두 가지 주요 속성, rotate.interval.ms와 rotate.schedule.interval.ms의 차이점과 동작 방식을 비교합니다. 지속적인 데이터 유입 여부, Exactly-once delivery 보장 조건 등 꼭 알아야 할 내용을 알아봅니다.</description></item><item><title>Redis Del Command</title><link>https://disj11.github.io/redis-del-command/</link><pubDate>Fri, 20 Oct 2023 20:57:17 +0900</pubDate><guid>https://disj11.github.io/redis-del-command/</guid><description>
Redis DEL 명령어와 UNLINK 명령어의 차이와, lazyfree-lazy-user-del 옵션에 대해 설명합니다.</description></item><item><title>HikariCP 자주 사용 하는 설정값 정리</title><link>https://disj11.github.io/hikari-cp-configuration/</link><pubDate>Sat, 02 Sep 2023 15:16:53 +0900</pubDate><guid>https://disj11.github.io/hikari-cp-configuration/</guid><description>
HikariCP 사용시 자주 사용 하는 설정 값들을 정리</description></item><item><title>JIT Compiler: JVM 성능 최적화의 핵심 기술</title><link>https://disj11.github.io/java-jit-compiler/</link><pubDate>Wed, 10 May 2023 23:56:05 +0900</pubDate><guid>https://disj11.github.io/java-jit-compiler/</guid><description>
JIT Compiler는 자바 코드 실행 속도를 획기적으로 향상시키는 JVM의 핵심 기술입니다. 이 글에서는 JIT Compiler의 작동 원리, Tiered Compilation, 임계값 설정 방법, 그리고 실제 성능 테스트를 통해 JIT의 효과를 자세히 살펴봅니다.</description></item><item><title>Shuffle Operation in Glue</title><link>https://disj11.github.io/shuffle-operation-in-glue/</link><pubDate>Wed, 10 May 2023 18:58:24 +0900</pubDate><guid>https://disj11.github.io/shuffle-operation-in-glue/</guid><description>
&lt;p>Glue workflow 사용중 3시간 정도 걸리는 Glue Job 이 발견되었다.
Worker 의 수를 10 -&amp;gt; 30 으로 올리니 17분 정도로 드라마틱하게 단축되어 왜 이런 현상이 발생하였는지 찾아보았다.&lt;/p>
&lt;p>Spark 에는 Shuffle Partition 이란 게 존재한다.
&lt;code>join&lt;/code>, &lt;code>groupBy&lt;/code> 등의 연산을 수행할 때 이 Shuffle Partition 이 사용된다.
이 Shuffle Partition 은 Spark의 성능에 가장 큰 영향을 미치는 Partition 이다.
연산에 쓰이는 메모리가 부족할 때 Shuffle Spill (데이터를 직렬화 하고 스토리지에 저장, 데이터 처리 이후에 역직렬화 후 연산 재개) 이 발생한다.
Shuffle Spill 이 일어나면, Task 가 지연되고 에러가 발생할 수 있다. 이 문제를 해결하기 위해서는 Core 당 메모리를 늘려야한다.&lt;/p></description></item><item><title>SQS Queue Types</title><link>https://disj11.github.io/sqs-queue-types/</link><pubDate>Sat, 06 May 2023 12:55:31 +0900</pubDate><guid>https://disj11.github.io/sqs-queue-types/</guid><description>
&lt;p>SQS 의 Queue type 에는 &lt;code>Standard&lt;/code> 와 &lt;code>FIFO&lt;/code> 가 있다.&lt;/p>
&lt;p>Standard queues 는 At-least-once delivery, Best-Effort Ordering 으로 작동한다.
At-least-once delivery 는 적어도 한번 메시지가 전달된다는 의미로 같은 메시지가 경우에 따라 두 번 이상 전달될 수 있다.
Best-Effort Ordering 은 경우에 따라 메시지의 순서가 보장되지 않는 것을 의미한다.
이러한 특성으로 Standard queues 를 사용하는 어플리케이션은 멱등성(idempotent) 을 보장해야 한다.
높은 처리량이 필요한 어플리케이션에 주로 사용한다.&lt;/p></description></item><item><title>메인 시퀀스로부터의 거리: 추상도와 불안정도를 활용한 아키텍처 평가</title><link>https://disj11.github.io/distance-from-the-main-sequence/</link><pubDate>Sun, 12 Mar 2023 14:09:09 +0900</pubDate><guid>https://disj11.github.io/distance-from-the-main-sequence/</guid><description>
소프트웨어 아키텍처에서 중요한 메트릭인 메인 시퀀스로부터의 거리를 중심으로, 이를 계산하는 데 사용되는 **추상도(abstractness)** 와 **불안정도(instability)** 의 개념과 계산 방법을 설명합니다. 또한, 메트릭의 시각적 표현을 통해 코드 품질을 평가하고 개선하는 방법을 다룹니다.</description></item><item><title>소프트웨어 응집도와 LCOM: 이해와 활용</title><link>https://disj11.github.io/cohesion-in-software-engineering/</link><pubDate>Sun, 12 Mar 2023 11:41:11 +0900</pubDate><guid>https://disj11.github.io/cohesion-in-software-engineering/</guid><description>
소프트웨어 설계의 핵심 개념인 **응집도(Cohesion)** 를 다양한 유형과 예시를 통해 쉽게 이해할 수 있도록 설명합니다. 또한, 클래스의 응집도를 정량적으로 평가하는 LCOM(Lack of Cohesion in Methods) 메트릭을 활용하여 설계 품질을 분석하고 개선하는 방법을 제시합니다.</description></item><item><title>확장성과 성능 최적화: 시스템 부하와 효율적인 대처 전략</title><link>https://disj11.github.io/what-you-need-to-know-first-for-scalability/</link><pubDate>Sun, 05 Feb 2023 12:15:15 +0900</pubDate><guid>https://disj11.github.io/what-you-need-to-know-first-for-scalability/</guid><description>
확장성이란 무엇인지부터 부하 매개변수와 성능 지표의 중요성, 그리고 꼬리 지연 시간과 효율적 자원 활용 전략까지, 시스템 확장성을 체계적으로 이해하고 최적화하는 방법을 알아봅니다.</description></item><item><title>효율적인 Kotlin 컬렉션 처리: Iterable과 Sequence의 차이점과 활용법</title><link>https://disj11.github.io/memory-efficient-iterable-data-processing-with-sequences/</link><pubDate>Tue, 10 Jan 2023 23:59:43 +0900</pubDate><guid>https://disj11.github.io/memory-efficient-iterable-data-processing-with-sequences/</guid><description>
Kotlin의 Iterable과 Sequence는 컬렉션을 처리하는 두 가지 주요 방식으로, 즉시 평가와 지연 평가라는 서로 다른 전략을 사용합니다. 이 글에서는 두 방식의 차이점, 성능 비교, 적합한 사용 사례를 중심으로 효율적인 Kotlin 코드를 작성하는 방법을 알아봅니다.</description></item><item><title>Kotlin: 확장 함수의 수신 객체</title><link>https://disj11.github.io/nullable-receiver-in-extension-functions-of-kotlin/</link><pubDate>Sun, 08 Jan 2023 21:22:27 +0900</pubDate><guid>https://disj11.github.io/nullable-receiver-in-extension-functions-of-kotlin/</guid><description>
확장 함수의 수신 객체는 null 값이 될 수 있다.</description></item><item><title>Kotlin에서 데이터 클래스를 사용할 때 주의할 점</title><link>https://disj11.github.io/notes-on-using-data-classes-in-kotlin/</link><pubDate>Sun, 08 Jan 2023 14:39:00 +0900</pubDate><guid>https://disj11.github.io/notes-on-using-data-classes-in-kotlin/</guid><description>
&lt;p>Kotlin에서 데이터 클래스를 주의해야 할 사항이 있다.
데이터 클래스는 자동으로 copy() 함수를 생성하는데, 이 함수를 통해 속성값을 수정한 새로운 인스턴스를 생성할 수 있게 된다.
클래스의 속성 중에 불변성을 유지해야 하는 속성이 있다면, 데이터 클래스의 사용은 위험할 수 있다.&lt;/p></description></item><item><title>Http Client in Java</title><link>https://disj11.github.io/http-client-in-java/</link><pubDate>Tue, 02 Nov 2021 18:11:57 +0900</pubDate><guid>https://disj11.github.io/http-client-in-java/</guid><description>
Java 11 에서 채택된 Http Client API 에 대하여</description></item><item><title>Number Formatter in Java</title><link>https://disj11.github.io/number-formatter-in-java/</link><pubDate>Mon, 01 Nov 2021 20:00:12 +0900</pubDate><guid>https://disj11.github.io/number-formatter-in-java/</guid><description>
간단한 예제를 통해 DecimalFormat 의 사용법을 알아보자.</description></item><item><title>Oauth2 에 대해서 알아보자</title><link>https://disj11.github.io/an-introduction-to-oauth2/</link><pubDate>Fri, 22 Oct 2021 10:08:30 +0900</pubDate><guid>https://disj11.github.io/an-introduction-to-oauth2/</guid><description>
OAuth 2.0 의 클라이언트 구현에 도움이 될 만한 정보를 위주로 OAuth 2.0 에 대하여 알아보자.</description></item><item><title>Date Time Formatter in Java</title><link>https://disj11.github.io/date-time-formatter-in-java/</link><pubDate>Wed, 29 Sep 2021 19:33:31 +0900</pubDate><guid>https://disj11.github.io/date-time-formatter-in-java/</guid><description>
Java 8 에서 추가된 DateTimeFormatter 클래스 사용법에 관한 간단한 정리</description></item><item><title>트랜잭션 격리 수준(Isolation Level)의 이해: 데이터 일관성과 성능의 균형</title><link>https://disj11.github.io/understanding-isolation-level-in-database-management/</link><pubDate>Tue, 28 Sep 2021 20:30:02 +0900</pubDate><guid>https://disj11.github.io/understanding-isolation-level-in-database-management/</guid><description>
트랜잭션 격리 수준은 데이터베이스에서 동시성 문제를 제어하고 데이터 일관성을 유지하기 위한 핵심 개념입니다. Dirty Read, Non-repeatable Read, Phantom Read 가 무엇인지 알아보고, 네 가지 주요 격리 수준(Read Uncommitted, Read Committed, Repeatable Read, Serializable)의 특징을 알아봅니다.</description></item><item><title>유니온 파인드</title><link>https://disj11.github.io/union-find/</link><pubDate>Wed, 05 Jun 2019 16:00:10 +0900</pubDate><guid>https://disj11.github.io/union-find/</guid><description>
유니온 파인드(Disjoint Set) 자료구조의 개념, 구현 방법, 경로 압축 최적화, 시간 복잡도를 자세히 설명합니다.</description></item></channel></rss>