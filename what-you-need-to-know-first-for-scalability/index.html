<!doctype html><html lang=ko><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XD9VVSGMKV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XD9VVSGMKV")}</script><title>확장성과 성능 최적화: 시스템 부하와 효율적인 대처 전략 ::
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=' 확장성 # 확장성은 시스템이 증가하는 부하에 효과적으로 대처할 수 있는 능력을 설명하는 데 사용되는 용어입니다. 하지만 &ldquo;X는 확장 가능하다&rdquo; 또는 &ldquo;Y는 확장성이 없다"라는 표현은 구체적인 의미를 전달하기 어렵습니다. 확장성을 논의한다는 것은 &ldquo;시스템이 커진다면 이에 대처하기 위한 선택은 무엇인가?&rdquo; 그리고 &ldquo;추가 부하를 처리하기 위해 자원을 어떻게 투입할 것인가?&rdquo; 와 같은 구체적인 질문을 고려한다는 뜻입니다.
'><meta name=keywords content="개발 블로그,개발블로그"><meta name=robots content="noodp"><link rel=canonical href=https://disj11.github.io/what-you-need-to-know-first-for-scalability/><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://disj11.github.io/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://disj11.github.io/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://disj11.github.io/img/favicon.png><link href=/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="확장성과 성능 최적화: 시스템 부하와 효율적인 대처 전략"><meta name=twitter:description content="확장성이란 무엇인지부터 부하 매개변수와 성능 지표의 중요성, 그리고 꼬리 지연 시간과 효율적 자원 활용 전략까지, 시스템 확장성을 체계적으로 이해하고 최적화하는 방법을 알아봅니다."><meta property="og:url" content="https://disj11.github.io/what-you-need-to-know-first-for-scalability/"><meta property="og:site_name" content="Life Log"><meta property="og:title" content="확장성과 성능 최적화: 시스템 부하와 효율적인 대처 전략"><meta property="og:description" content="확장성이란 무엇인지부터 부하 매개변수와 성능 지표의 중요성, 그리고 꼬리 지연 시간과 효율적 자원 활용 전략까지, 시스템 확장성을 체계적으로 이해하고 최적화하는 방법을 알아봅니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-05T12:15:15+09:00"><meta property="article:modified_time" content="2024-12-29T11:33:00+09:00"><meta property="article:tag" content="Development"><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4.14.2/dist/algoliasearch-lite.umd.js integrity="sha256-dImjLPUsG/6p3+i7gVKBiDM8EemJAhQ0VvkRK2pVsQY=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@algolia/autocomplete-js></script><script>function initAutoComplete(){const e=document.createElement("div");e.id="autocomplete";const t=document.createElement("li");t.appendChild(e),document.querySelector("nav.menu > ul")?.prepend(t)}window.onload=()=>{initAutoComplete();const e=algoliasearch("XPOQNA4T7C","da59fb86972a7cc1eb6f3172adf593a8"),{autocomplete:t,getAlgoliaResults:n}=window["@algolia/autocomplete-js"];t({container:"#autocomplete",placeholder:"Search for posts",getSources({query:t}){return[{sourceId:"posts",getItems(){return n({searchClient:e,queries:[{indexName:"lifelog",query:t,params:{hitsPerPage:5,attributesToSnippet:["title:10","content:35"],snippetEllipsisText:"…"}}]})},templates:{header({html:e}){return e`
                                    <span class="aa-SourceHeaderTitle">Posts</span>
                                    <div class="aa-SourceHeaderLine"/>
                                `},item({item:e,components:n,html:s}){return s`
                                    <a class="aa-ItemLink" href="${e.href}?search=${t}">
                                        <div class="aa-ItemContent">
                                            <div class="aa-ItemContentBody">
                                                <div class="aa-ItemContentTitle">
                                                    ${n.Highlight({hit:e,attribute:"title"})}
                                                </div>
                                                <div class="aa-ItemContentDescription">
                                                    ${n.Snippet({hit:e,attribute:"content"})}
                                                </div>
                                            </div>
                                        </div>
                                    </a>
                                `},noResults(){return"No posts for this query."}}}]}})}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"]]}}</script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>Life Log</span>
<span class=logo__cursor></span>
</a><span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/notes>Notes</a></li><li><a href=/tags>Tags</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/notes>Notes</a></li><li><a href=/tags>Tags</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><article class=post><h1 class=post-title>확장성과 성능 최적화: 시스템 부하와 효율적인 대처 전략</h1><div class=post-meta><time class=post-date>2023-02-05
</time><span class=post-moddate>(Modified:
2024-12-29)</span></div><span class=post-tags><a href=https://disj11.github.io/tags/development/>#development</a>&nbsp;</span><div class=post-content><h2 id=확장성>확장성
<a href=#%ed%99%95%ec%9e%a5%ec%84%b1 class=h-anchor aria-hidden=true>#</a></h2><p><strong>확장성</strong>은 시스템이 증가하는 부하에 효과적으로 대처할 수 있는 능력을 설명하는 데 사용되는 용어입니다. 하지만 &ldquo;X는 확장 가능하다&rdquo; 또는 &ldquo;Y는 확장성이 없다"라는 표현은 구체적인 의미를 전달하기 어렵습니다. 확장성을 논의한다는 것은 <strong>&ldquo;시스템이 커진다면 이에 대처하기 위한 선택은 무엇인가?&rdquo;</strong> 그리고 <strong>&ldquo;추가 부하를 처리하기 위해 자원을 어떻게 투입할 것인가?&rdquo;</strong> 와 같은 구체적인 질문을 고려한다는 뜻입니다.</p><p>확장성을 평가하려면 시스템이 증가하는 부하에 어떻게 반응하는지, 이를 해결하기 위해 어떤 전략을 사용할 수 있는지를 명확히 이해해야 합니다. 특히, 수직적 확장(scale-up)과 수평적 확장(scale-out)의 차이를 이해하는 것이 중요합니다.</p><ul><li><strong>수직적 확장(scale-up):</strong> 기존 시스템의 성능을 높이기 위해 더 강력한 하드웨어를 추가하거나 업그레이드하는 방식입니다. 예를 들어, 더 빠른 CPU나 더 많은 메모리를 추가하는 것이 이에 해당합니다.</li><li><strong>수평적 확장(scale-out):</strong> 여러 대의 시스템을 추가하여 부하를 분산시키는 방식입니다. 예를 들어, 웹 서버를 여러 대로 늘리고 로드 밸런서를 통해 트래픽을 분산시키는 방법이 있습니다.</li></ul><p>각 방법에는 장단점이 있으며, 상황에 따라 적합한 전략을 선택해야 합니다.</p><h2 id=부하-기술하기>부하 기술하기
<a href=#%eb%b6%80%ed%95%98-%ea%b8%b0%ec%88%a0%ed%95%98%ea%b8%b0 class=h-anchor aria-hidden=true>#</a></h2><p>확장성을 논의하려면 현재 시스템의 부하를 간결하고 명확하게 기술해야 합니다. 이를 통해 <strong>&ldquo;부하가 두 배로 증가하면 어떤 일이 발생할까?&rdquo;</strong> 와 같은 시나리오를 분석할 수 있습니다.</p><p>부하는 <strong>부하 매개변수(load parameter)</strong> 라는 몇 가지 숫자로 표현됩니다. 시스템마다 적합한 부하 매개변수는 다르지만, 일반적으로 다음과 같은 항목들이 포함됩니다:</p><ul><li>웹 서버의 초당 요청 수</li><li>데이터베이스의 읽기 대 쓰기 비율</li><li>동시 활성 사용자(active user) 수</li><li>캐시 적중률(cache hit rate)</li></ul><p>이러한 매개변수는 평균적인 상황을 나타낼 수도 있지만, 때로는 극단적인 경우(예: 피크 타임, 병목 현상)가 시스템 성능에 더 큰 영향을 미칠 수 있습니다. 따라서 평균뿐만 아니라 극단적인 상황도 함께 고려해야 합니다.</p><p>예를 들어, 대규모 전자상거래 플랫폼에서는 초당 요청 수와 동시 활성 사용자가 중요한 부하 매개변수가 될 수 있습니다. 반면, 스트리밍 서비스에서는 캐시 적중률과 네트워크 대역폭 사용량이 주요 지표가 될 것입니다.</p><h2 id=성능-기술하기>성능 기술하기
<a href=#%ec%84%b1%eb%8a%a5-%ea%b8%b0%ec%88%a0%ed%95%98%ea%b8%b0 class=h-anchor aria-hidden=true>#</a></h2><p>부하를 정의한 후에는 부하가 증가했을 때 시스템 성능이 어떻게 변화하는지 조사할 필요가 있습니다. 이를 위해 다음과 같은 질문을 던질 수 있습니다:</p><ul><li><strong>부하 매개변수를 증가시키고 자원(CPU, 메모리, 네트워크 대역폭)은 그대로 유지하면 성능에 어떤 영향을 미칠까요?</strong></li><li><strong>부하 매개변수를 증가시키면서 성능을 유지하려면 자원을 얼마나 추가해야 할까요?</strong></li></ul><p>이 질문들에 답하려면 시스템 성능을 측정하고 평가할 수 있는 지표가 필요합니다.</p><h3 id=주요-성능-지표>주요 성능 지표
<a href=#%ec%a3%bc%ec%9a%94-%ec%84%b1%eb%8a%a5-%ec%a7%80%ed%91%9c class=h-anchor aria-hidden=true>#</a></h3><ol><li><p><strong>일괄 처리 시스템(batch processing system):</strong></p><ul><li>주로 <strong>처리량(throughput)</strong> 에 관심을 둡니다.</li><li>예: 초당 처리 가능한 레코드 수 또는 일정 크기의 데이터 집합을 처리하는 데 걸리는 시간.</li></ul></li><li><p><strong>온라인 시스템(online system):</strong></p><ul><li>주로 <strong>응답 시간(response time)</strong> 에 관심을 둡니다.</li><li>응답 시간은 클라이언트가 요청을 보내고 응답을 받기까지 걸리는 시간으로 정의됩니다.</li></ul></li></ol><p>응답 시간은 고정된 값이 아니라 요청마다 변동될 수 있으므로, 단일 숫자가 아닌 <strong>분포(distribution)</strong> 로 이해해야 합니다.</p><h3 id=응답-시간-분석>응답 시간 분석
<a href=#%ec%9d%91%eb%8b%b5-%ec%8b%9c%ea%b0%84-%eb%b6%84%ec%84%9d class=h-anchor aria-hidden=true>#</a></h3><p>평균 응답 시간은 전체적인 경향을 파악하기에는 유용하지만, 실제 사용자 경험을 정확히 반영하지 못할 수 있습니다. 이는 평균값이 극단적인 값(특이 값, outlier)에 의해 왜곡될 가능성이 있기 때문입니다. 따라서 평균 대신 <strong>백분위(percentile)</strong> 를 사용하는 것이 더 적합합니다.</p><ul><li><strong>중앙값(median):</strong> 응답 시간을 빠른 순서대로 정렬했을 때 중간값으로, 50%의 요청이 이 시간 이하로 처리됨을 의미합니다.</li><li><strong>상위 백분위:</strong> 95분위(p95), 99분위(p99), 99.9분위(p999) 등이 자주 사용됩니다.<ul><li>예: 95분위 응답 시간이 1.5초라면, 100개의 요청 중 95개는 1.5초 이내에 처리되고 나머지 5개는 더 오래 걸린다는 뜻입니다.</li></ul></li></ul><h3 id=꼬리-지연-시간tail-latency>꼬리 지연 시간(Tail Latency)
<a href=#%ea%bc%ac%eb%a6%ac-%ec%a7%80%ec%97%b0-%ec%8b%9c%ea%b0%84tail-latency class=h-anchor aria-hidden=true>#</a></h3><p><strong>꼬리 지연 시간</strong>은 상위 백분위에서 나타나는 높은 응답 시간을 의미하며, 이는 사용자 경험에 큰 영향을 미칩니다. 예를 들어, 대부분의 요청이 빠르게 처리되더라도 일부 요청에서 지나치게 긴 응답 시간이 발생하면 사용자는 서비스가 느리다고 느낄 수 있습니다. 따라서 꼬리 지연 시간을 줄이는 것은 고품질 서비스를 제공하는 데 중요한 요소입니다.</p><h2 id=효율적-확장을-위한-전략>효율적 확장을 위한 전략
<a href=#%ed%9a%a8%ec%9c%a8%ec%a0%81-%ed%99%95%ec%9e%a5%ec%9d%84-%ec%9c%84%ed%95%9c-%ec%a0%84%eb%9e%b5 class=h-anchor aria-hidden=true>#</a></h2><p>확장성과 관련하여 단순히 자원을 추가하는 방식 외에도 효율적으로 자원을 활용하거나 최적화하는 방법도 중요합니다. 다음과 같은 전략들이 유용할 수 있습니다:</p><ul><li><strong>캐싱 전략 강화:</strong> 자주 조회되는 데이터를 캐시에 저장하여 데이터베이스 조회 부담을 줄입니다.</li><li><strong>데이터베이스 쿼리 최적화:</strong> 쿼리 실행 계획을 개선하거나 인덱스를 추가하여 데이터베이스 성능을 향상시킵니다.</li><li><strong>로드 밸런싱:</strong> 트래픽을 여러 서버로 분산시켜 병목 현상을 방지합니다.</li><li><strong>비동기 처리:</strong> 시간이 오래 걸리는 작업은 비동기로 처리하여 주요 작업 흐름의 응답 시간을 단축합니다.</li></ul><p>또한, 부하와 성능 간 관계를 시각적으로 표현한 그래프나 도표를 활용하면 문제를 분석하고 해결책을 설계하는 데 큰 도움이 됩니다.</p><p>위 내용을 바탕으로 확장성과 관련된 논의를 진행하면 보다 체계적이고 실질적인 접근이 가능할 것입니다.</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>다른 게시물 읽기</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://disj11.github.io/cohesion-in-software-engineering/><span class=button__icon>←</span>
<span class=button__text>소프트웨어 응집도와 LCOM: 이해와 활용</span>
</a></span><span class="button next"><a href=https://disj11.github.io/memory-efficient-iterable-data-processing-with-sequences/><span class=button__text>효율적인 Kotlin 컬렉션 처리: Iterable과 Sequence의 차이점과 활용법</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>Life Log</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span><a href=https://github.com/panr/hugo-theme-hello-friend target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>