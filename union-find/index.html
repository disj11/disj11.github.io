<!doctype html><html lang=ko><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XD9VVSGMKV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XD9VVSGMKV")}</script><title>유니온 파인드 ::
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" 개요 # 유니온 파인드는 Disjoint Set (서로소 집합) 또는 Merge-Find Set (병합-찾기 집합) 으로 불리며, 서로소인 집합들을 표현하는 자료구조입니다. 여기서 서로소 집합이란, 각 집합 간에 교집합의 원소가 하나도 없으며, 모든 집합의 합집합이 전체 원소를 포함하는 경우를 의미합니다. 유니온 파인드는 기본적으로 union(집합 병합)과 find(루트 찾기)라는 두 가지 연산만을 지원합니다.
"><meta name=keywords content="개발 블로그,개발블로그"><meta name=robots content="noodp"><link rel=canonical href=https://disj11.github.io/union-find/><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://disj11.github.io/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://disj11.github.io/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://disj11.github.io/img/favicon.png><link href=/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="유니온 파인드"><meta name=twitter:description content="유니온 파인드(Disjoint Set) 자료구조의 개념, 구현 방법, 경로 압축 최적화, 시간 복잡도를 자세히 설명합니다."><meta property="og:url" content="https://disj11.github.io/union-find/"><meta property="og:site_name" content="Life Log"><meta property="og:title" content="유니온 파인드"><meta property="og:description" content="유니온 파인드(Disjoint Set) 자료구조의 개념, 구현 방법, 경로 압축 최적화, 시간 복잡도를 자세히 설명합니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-06-05T16:00:10+09:00"><meta property="article:modified_time" content="2024-12-29T20:09:02+09:00"><meta property="article:tag" content="Data Structure"><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4.14.2/dist/algoliasearch-lite.umd.js integrity="sha256-dImjLPUsG/6p3+i7gVKBiDM8EemJAhQ0VvkRK2pVsQY=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@algolia/autocomplete-js></script><script>function initAutoComplete(){const e=document.createElement("div");e.id="autocomplete";const t=document.createElement("li");t.appendChild(e),document.querySelector("nav.menu > ul")?.prepend(t)}window.onload=()=>{initAutoComplete();const e=algoliasearch("XPOQNA4T7C","da59fb86972a7cc1eb6f3172adf593a8"),{autocomplete:t,getAlgoliaResults:n}=window["@algolia/autocomplete-js"];t({container:"#autocomplete",placeholder:"Search for posts",getSources({query:t}){return[{sourceId:"posts",getItems(){return n({searchClient:e,queries:[{indexName:"lifelog",query:t,params:{hitsPerPage:5,attributesToSnippet:["title:10","content:35"],snippetEllipsisText:"…"}}]})},templates:{header({html:e}){return e`
                                    <span class="aa-SourceHeaderTitle">Posts</span>
                                    <div class="aa-SourceHeaderLine"/>
                                `},item({item:e,components:n,html:s}){return s`
                                    <a class="aa-ItemLink" href="${e.href}?search=${t}">
                                        <div class="aa-ItemContent">
                                            <div class="aa-ItemContentBody">
                                                <div class="aa-ItemContentTitle">
                                                    ${n.Highlight({hit:e,attribute:"title"})}
                                                </div>
                                                <div class="aa-ItemContentDescription">
                                                    ${n.Snippet({hit:e,attribute:"content"})}
                                                </div>
                                            </div>
                                        </div>
                                    </a>
                                `},noResults(){return"No posts for this query."}}}]}})}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"]]}}</script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>Life Log</span>
<span class=logo__cursor></span>
</a><span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/notes>Notes</a></li><li><a href=/tags>Tags</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/notes>Notes</a></li><li><a href=/tags>Tags</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><article class=post><h1 class=post-title>유니온 파인드</h1><div class=post-meta><time class=post-date>2019-06-05
</time><span class=post-moddate>(Modified:
2024-12-29)</span></div><span class=post-tags><a href=https://disj11.github.io/tags/data-structure/>#data structure</a>&nbsp;</span><div class=post-content><h2 id=개요>개요
<a href=#%ea%b0%9c%ec%9a%94 class=h-anchor aria-hidden=true>#</a></h2><p>유니온 파인드는 <strong>Disjoint Set (서로소 집합)</strong> 또는 <strong>Merge-Find Set (병합-찾기 집합)</strong> 으로 불리며, 서로소인 집합들을 표현하는 자료구조입니다. 여기서 서로소 집합이란, 각 집합 간에 교집합의 원소가 하나도 없으며, 모든 집합의 합집합이 전체 원소를 포함하는 경우를 의미합니다. 유니온 파인드는 기본적으로 <strong>union</strong>(집합 병합)과 <strong>find</strong>(루트 찾기)라는 두 가지 연산만을 지원합니다.</p><h2 id=예시>예시
<a href=#%ec%98%88%ec%8b%9c class=h-anchor aria-hidden=true>#</a></h2><p>초기 상태에서는 다음과 같은 8개의 서로소 집합이 존재한다고 가정하겠습니다.</p><p>{1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}</p><p>위 상태는 초기의 크기가 8인 유니온 파인드 자료구조를 나타내며, 각각 독립적인 집합을 포함하고 있습니다.</p><p>몇 번의 연산이 이루어진 후, 다음과 같은 형태로 집합이 병합되었다고 가정해보겠습니다.</p><p>{1, 2, 5, 6, 8}, {3, 4}, {7}</p><p>아래 그림은 병합 이후의 상태를 트리 구조로 표현한 것입니다.</p><p><img src=/images/union_find_forest.png alt></p><p>트리에서 가장 위에 있는 노드를 <strong>루트(root)</strong> 라고 하며, 해당 트리에 속한 모든 정점은 동일한 집합에 속해 있습니다. 같은 집합을 표현하는 방법은 여러 가지가 있을 수 있으며, 위 그림은 그 중 하나의 예시입니다.</p><h2 id=구현>구현
<a href=#%ea%b5%ac%ed%98%84 class=h-anchor aria-hidden=true>#</a></h2><h3 id=find-연산><strong>find 연산</strong>
<a href=#find-%ec%97%b0%ec%82%b0 class=h-anchor aria-hidden=true>#</a></h3><p>find 연산은 두 원소가 같은 집합에 속해 있는지 확인하기 위해 사용됩니다. 이를 위해 두 원소의 루트를 찾아서 루트가 동일한지 비교합니다. find 연산은 특정 원소의 루트를 찾아주는 역할을 합니다.</p><p>다음은 find 연산의 기본 구현입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 원소 n을 받아 n의 root 노드를 반환합니다.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param n 루트를 찾을 정점
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @return root 노드
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (parent<span style=color:#f92672>[</span>n<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> n; <span style=color:#75715e>// 자신이 루트 노드일 경우</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> find(parent<span style=color:#f92672>[</span>n<span style=color:#f92672>]</span>); <span style=color:#75715e>// 재귀적으로 부모 노드를 따라 올라감</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위 코드는 <code>parent</code> 배열을 사용하여 각 노드의 부모를 저장한다고 가정한 구현입니다. 여기서 루트 노드는 <code>parent[n] &lt; 0</code>으로 표시됩니다. 하지만 이 방식에는 단점이 있습니다. 예를 들어, 위 그림과 같은 트리에서 <code>find(6)</code>을 호출하면, 경로가 일직선으로 길어질 경우 많은 재귀 호출이 발생하게 됩니다.</p><p>이를 개선하기 위해 <strong>경로 압축(path compression)</strong> 을 적용할 수 있습니다. 아래는 경로 압축을 적용한 개선된 코드입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (parent<span style=color:#f92672>[</span>n<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> n;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    parent<span style=color:#f92672>[</span>n<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> find(parent<span style=color:#f92672>[</span>n<span style=color:#f92672>]</span>); <span style=color:#75715e>// 부모를 루트로 직접 설정하여 경로 압축</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> parent<span style=color:#f92672>[</span>n<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>경로 압축은 재귀 호출 과정에서 트리의 구조를 평평하게 만들어줍니다. 따라서 이후의 find 연산이 더 빠르게 수행될 수 있습니다. 경로 압축을 적용한 결과는 아래 그림과 같이 나타납니다.</p><p><img src=/images/union_find_forest2.png alt></p><p>경로 압축을 적용한 find 연산의 시간 복잡도는 매우 효율적이며, 이론적으로 \( O(\log^* N) \)이라고 표현됩니다. 여기서 \( \log^* N \)은 로그 스타 함수라고 불리며, 매우 느리게 증가하기 때문에 실질적으로 상수 시간에 가까운 성능을 보입니다.</p><h4 id=로그-스타-함수><strong>로그 스타 함수</strong>
<a href=#%eb%a1%9c%ea%b7%b8-%ec%8a%a4%ed%83%80-%ed%95%a8%ec%88%98 class=h-anchor aria-hidden=true>#</a></h4><p>로그 스타 함수(\( \log^* N \))는 반복 로그 함수라고도 불리며, 매우 느리게 증가하는 함수입니다. 이는 다음과 같이 정의됩니다:</p><ul><li>\( \log^* N \): 어떤 양수 \( N \)에 대해 로그를 반복적으로 취해 그 결과가 \( 1 \) 이하가 될 때까지 몇 번 로그를 취했는지를 나타냅니다.</li></ul><p>예를 들어:</p><ul><li>\( N = 16 \): \( \log_2(16) = 4 \), \( \log_2(4) = 2 \), \( \log_2(2) = 1 \). 따라서 \( \log^*(16) = 3 \).</li><li>\( N = 2^{65536} \): 매우 큰 값임에도 불구하고 \( \log^*(N) = 5 \).</li></ul><h3 id=union-연산><strong>union 연산</strong>
<a href=#union-%ec%97%b0%ec%82%b0 class=h-anchor aria-hidden=true>#</a></h3><p>union 연산은 두 개의 서로소 집합을 하나로 합치는 작업을 수행합니다. 유니온 파인드 자료구조에서는 find 연산과 union 연산만 제공되며, 한 번 합쳐진 집합을 다시 분리하는 것은 어렵습니다. 그러나 보통 합치는 작업만 필요한 경우에 유용하게 사용됩니다.</p><p>다음은 union 연산의 기본 구현입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>merge</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>    a <span style=color:#f92672>=</span> find(a); <span style=color:#75715e>// a의 루트를 찾음</span>
</span></span><span style=display:flex><span>    b <span style=color:#f92672>=</span> find(b); <span style=color:#75715e>// b의 루트를 찾음</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>!=</span> b) {
</span></span><span style=display:flex><span>        parent<span style=color:#f92672>[</span>b<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> a; <span style=color:#75715e>// b의 루트를 a로 변경하여 병합</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위 코드에서는 두 원소 \( a \)와 \( b \)가 속한 집합의 루트를 각각 찾은 후, \( a \)와 \( b \)가 서로 다른 집합에 속해 있을 경우 \( b \)의 루트를 \( a \)로 설정하여 병합합니다.</p><p>여기서 함수명을 <code>merge</code>로 사용한 이유는 C 언어에서 <code>union</code>이 예약어로 사용되기 때문입니다. 실제 구현에서는 <code>union</code>이라는 이름 대신 다른 이름을 사용하는 경우도 많습니다.</p><h3 id=시간-복잡도>시간 복잡도
<a href=#%ec%8b%9c%ea%b0%84-%eb%b3%b5%ec%9e%a1%eb%8f%84 class=h-anchor aria-hidden=true>#</a></h3><ul><li><strong>find 연산</strong>: 경로 압축을 적용하면 이론적으로 \( O(\log^* N) \), 실질적으로 상수 시간에 가까움.</li><li><strong>union 연산</strong>: find 연산에 의존하므로 동일하게 \( O(\log^* N) \).</li></ul><p>따라서 크기가 \( N \)인 유니온 파인드 자료구조에서 \( M \)번의 union 또는 find 연산을 수행할 경우 최악의 시간 복잡도는 \( O(M \cdot \log^* N) \)입니다.</p><hr><p>참고자료:</p><ul><li><a href=https://kks227.blog.me/>https://kks227.blog.me/</a></li></ul></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>다른 게시물 읽기</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://disj11.github.io/understanding-isolation-level-in-database-management/><span class=button__icon>←</span>
<span class=button__text>트랜잭션 격리 수준(Isolation Level)의 이해: 데이터 일관성과 성능의 균형</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>Life Log</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2024 Powered by <a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span><a href=https://github.com/panr/hugo-theme-hello-friend target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>