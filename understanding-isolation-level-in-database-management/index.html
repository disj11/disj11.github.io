<!doctype html><html lang=ko><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XD9VVSGMKV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XD9VVSGMKV")}</script><title>트랜잭션 격리 수준(Isolation Level)의 이해: 데이터 일관성과 성능의 균형 ::
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" 개요 # Isolation level은 트랜잭션에서 일관성이 없는 데이터를 어느 수준까지 허용할 것인지 정의하는 데이터베이스의 중요한 개념입니다. 격리 수준이 낮을수록 여러 사용자가 동일한 데이터에 동시에 접근할 수 있어 성능이 향상되지만, 이로 인해 잘못된 데이터를 읽거나 데이터 업데이트가 손실되는 문제가 발생할 수 있습니다.
"><meta name=keywords content="개발 블로그,개발블로그"><meta name=robots content="noodp"><link rel=canonical href=https://disj11.github.io/understanding-isolation-level-in-database-management/><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://disj11.github.io/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://disj11.github.io/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://disj11.github.io/img/favicon.png><link href=/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="트랜잭션 격리 수준(Isolation Level)의 이해: 데이터 일관성과 성능의 균형"><meta name=twitter:description content="트랜잭션 격리 수준은 데이터베이스에서 동시성 문제를 제어하고 데이터 일관성을 유지하기 위한 핵심 개념입니다. Dirty Read, Non-repeatable Read, Phantom Read 가 무엇인지 알아보고, 네 가지 주요 격리 수준(Read Uncommitted, Read Committed, Repeatable Read, Serializable)의 특징을 알아봅니다."><meta property="og:url" content="https://disj11.github.io/understanding-isolation-level-in-database-management/"><meta property="og:site_name" content="Life Log"><meta property="og:title" content="트랜잭션 격리 수준(Isolation Level)의 이해: 데이터 일관성과 성능의 균형"><meta property="og:description" content="트랜잭션 격리 수준은 데이터베이스에서 동시성 문제를 제어하고 데이터 일관성을 유지하기 위한 핵심 개념입니다. Dirty Read, Non-repeatable Read, Phantom Read 가 무엇인지 알아보고, 네 가지 주요 격리 수준(Read Uncommitted, Read Committed, Repeatable Read, Serializable)의 특징을 알아봅니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-28T20:30:02+09:00"><meta property="article:modified_time" content="2024-12-29T11:14:00+09:00"><meta property="article:tag" content="Database"><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4.14.2/dist/algoliasearch-lite.umd.js integrity="sha256-dImjLPUsG/6p3+i7gVKBiDM8EemJAhQ0VvkRK2pVsQY=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@algolia/autocomplete-js></script><script>function initAutoComplete(){const e=document.createElement("div");e.id="autocomplete";const t=document.createElement("li");t.appendChild(e),document.querySelector("nav.menu > ul")?.prepend(t)}window.onload=()=>{initAutoComplete();const e=algoliasearch("XPOQNA4T7C","da59fb86972a7cc1eb6f3172adf593a8"),{autocomplete:t,getAlgoliaResults:n}=window["@algolia/autocomplete-js"];t({container:"#autocomplete",placeholder:"Search for posts",getSources({query:t}){return[{sourceId:"posts",getItems(){return n({searchClient:e,queries:[{indexName:"lifelog",query:t,params:{hitsPerPage:5,attributesToSnippet:["title:10","content:35"],snippetEllipsisText:"…"}}]})},templates:{header({html:e}){return e`
                                    <span class="aa-SourceHeaderTitle">Posts</span>
                                    <div class="aa-SourceHeaderLine"/>
                                `},item({item:e,components:n,html:s}){return s`
                                    <a class="aa-ItemLink" href="${e.href}?search=${t}">
                                        <div class="aa-ItemContent">
                                            <div class="aa-ItemContentBody">
                                                <div class="aa-ItemContentTitle">
                                                    ${n.Highlight({hit:e,attribute:"title"})}
                                                </div>
                                                <div class="aa-ItemContentDescription">
                                                    ${n.Snippet({hit:e,attribute:"content"})}
                                                </div>
                                            </div>
                                        </div>
                                    </a>
                                `},noResults(){return"No posts for this query."}}}]}})}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"]]}}</script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>Life Log</span>
<span class=logo__cursor></span>
</a><span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/notes>Notes</a></li><li><a href=/tags>Tags</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/notes>Notes</a></li><li><a href=/tags>Tags</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><article class=post><h1 class=post-title>트랜잭션 격리 수준(Isolation Level)의 이해: 데이터 일관성과 성능의 균형</h1><div class=post-meta><time class=post-date>2021-09-28
</time><span class=post-moddate>(Modified:
2024-12-29)</span></div><span class=post-tags><a href=https://disj11.github.io/tags/database/>#database</a>&nbsp;</span><div class=post-content><h2 id=개요>개요
<a href=#%ea%b0%9c%ec%9a%94 class=h-anchor aria-hidden=true>#</a></h2><p><strong>Isolation level</strong>은 트랜잭션에서 <strong>일관성이 없는 데이터</strong>를 어느 수준까지 허용할 것인지 정의하는 데이터베이스의 중요한 개념입니다. <strong>격리 수준</strong>이 낮을수록 여러 사용자가 동일한 데이터에 동시에 접근할 수 있어 <strong>성능</strong>이 향상되지만, 이로 인해 잘못된 데이터를 읽거나 데이터 업데이트가 손실되는 문제가 발생할 수 있습니다.</p><p>반대로 <strong>격리 수준</strong>이 높아질수록 데이터의 <strong>일관성</strong>은 보장되지만, 동시에 접근 가능한 사용자의 수가 줄어들어 성능이 저하될 수 있습니다. 이러한 균형을 맞추기 위해 대부분의 데이터베이스 시스템은 네 가지 격리 수준을 제공하며, 애플리케이션의 요구 사항에 따라 적절한 격리 수준을 선택할 수 있도록 설계되었습니다.</p><hr><h2 id=용어-설명>용어 설명
<a href=#%ec%9a%a9%ec%96%b4-%ec%84%a4%eb%aa%85 class=h-anchor aria-hidden=true>#</a></h2><p>격리 수준을 이해하기 위해 먼저 <strong>Dirty Read</strong>, <strong>Non-repeatable Read</strong>, <strong>Phantom Read</strong>라는 개념을 알아야 합니다. 이는 각각 트랜잭션 간의 충돌로 인해 발생할 수 있는 대표적인 문제들입니다.</p><h3 id=dirty-read>Dirty Read
<a href=#dirty-read class=h-anchor aria-hidden=true>#</a></h3><p>커밋되지 않은 데이터를 다른 트랜잭션에서 읽는 것을 허용할 때 발생합니다. 이는 롤백된 데이터를 읽음으로써 잘못된 정보를 기반으로 동작하게 되는 문제를 초래합니다.</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td><code>SELECT age FROM users WHERE id = 1;</code></td><td></td></tr><tr><td></td><td><code>UPDATE users SET age = 21 WHERE id = 1;</code></td></tr><tr><td><code>SELECT age FROM users WHERE id = 1;</code></td><td></td></tr><tr><td></td><td><code>ROLLBACK;</code></td></tr></tbody></table><p>위 예시에서 Transaction 1은 커밋되지 않은 데이터를 읽었기 때문에, 최종적으로 롤백된 값(21)을 잘못 참조하게 됩니다.</p><hr><h3 id=non-repeatable-read>Non-repeatable Read
<a href=#non-repeatable-read class=h-anchor aria-hidden=true>#</a></h3><p>한 트랜잭션 내에서 동일한 쿼리를 두 번 수행했을 때, 그 사이에 다른 트랜잭션이 데이터를 수정하거나 삭제하여 첫 번째 조회와 두 번째 조회 결과가 달라지는 현상입니다.</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td><code>SELECT age FROM users WHERE id = 1;</code></td><td></td></tr><tr><td></td><td><code>UPDATE users SET age = 21 WHERE id = 1;</code></td></tr><tr><td></td><td><code>COMMIT;</code></td></tr><tr><td><code>SELECT age FROM users WHERE id = 1;</code></td><td></td></tr><tr><td><code>COMMIT;</code></td><td></td></tr></tbody></table><p>위 예시에서 Transaction 1은 같은 데이터를 두 번 조회했지만, 중간에 Transaction 2가 데이터를 수정했기 때문에 결과가 일관되지 않습니다.</p><hr><h3 id=phantom-read>Phantom Read
<a href=#phantom-read class=h-anchor aria-hidden=true>#</a></h3><p>한 트랜잭션 내에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫 번째 쿼리에서는 없었던 새로운 레코드가 이후 쿼리에서 나타나는 현상을 말합니다. 이는 주로 레코드 삽입과 관련된 문제입니다.</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td><code>SELECT age FROM users WHERE age &lt; 20</code></td><td></td></tr><tr><td></td><td><code>INSERT INTO users(name, age) VALUES ('홍길동', 10);</code></td></tr><tr><td></td><td><code>COMMIT;</code></td></tr><tr><td><code>SELECT age FROM users WHERE age &lt; 20;</code></td><td></td></tr><tr><td><code>COMMIT;</code></td><td></td></tr></tbody></table><p>위 예시에서 Transaction 1은 처음에는 조건에 맞는 레코드가 없었지만, 중간에 Transaction 2가 새로운 레코드를 삽입하면서 결과가 달라집니다.</p><hr><h2 id=isolation-level>Isolation Level
<a href=#isolation-level class=h-anchor aria-hidden=true>#</a></h2><p>데이터베이스는 위와 같은 문제를 해결하기 위해 네 가지 격리 수준을 제공합니다. 각 격리 수준은 허용되는 동시성 문제와 성능 간의 균형을 다르게 설정합니다.</p><h3 id=read-uncommitted>Read Uncommitted
<a href=#read-uncommitted class=h-anchor aria-hidden=true>#</a></h3><ul><li>커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용합니다.</li><li>가장 낮은 격리 수준으로, <strong>Dirty Read</strong>, <strong>Non-repeatable Read</strong>, <strong>Phantom Read</strong> 문제가 모두 발생할 수 있습니다.</li><li>성능은 가장 뛰어나지만 데이터 일관성이 낮습니다.</li></ul><hr><h3 id=read-committed>Read Committed
<a href=#read-committed class=h-anchor aria-hidden=true>#</a></h3><ul><li>커밋된 데이터만 다른 트랜잭션이 읽는 것을 허용합니다.</li><li><strong>Dirty Read</strong> 문제는 방지하지만, 여전히 <strong>Non-repeatable Read</strong>와 <strong>Phantom Read</strong> 문제가 발생할 수 있습니다.</li><li>대부분의 DBMS가 기본 격리 수준으로 채택하고 있는 모드입니다.</li></ul><hr><h3 id=repeatable-read>Repeatable Read
<a href=#repeatable-read class=h-anchor aria-hidden=true>#</a></h3><ul><li>한 트랜잭션이 읽은 데이터를 다른 트랜잭션이 수정하거나 삭제하지 못하도록 보장합니다.</li><li><strong>Non-repeatable Read</strong> 문제를 방지하며, 동일한 데이터를 여러 번 조회해도 항상 일관된 결과를 얻을 수 있습니다.</li><li>그러나 여전히 <strong>Phantom Read</strong> 문제가 발생할 가능성이 있습니다.</li></ul><hr><h3 id=serializable>Serializable
<a href=#serializable class=h-anchor aria-hidden=true>#</a></h3><ul><li>가장 높은 격리 수준으로, 모든 트랜잭션을 직렬화하여 처리하는 것처럼 동작합니다.</li><li>선행 트랜잭션이 읽은 데이터에 대해 후행 트랜잭션이 수정, 삭제뿐만 아니라 새로운 레코드 삽입도 불가능하게 만듭니다.</li><li>완벽한 데이터 일관성을 보장하지만 성능 저하가 크며, 동시성 처리 능력이 크게 제한됩니다.</li></ul><hr><h2 id=결론>결론
<a href=#%ea%b2%b0%eb%a1%a0 class=h-anchor aria-hidden=true>#</a></h2><p>Isolation level은 트랜잭션 간의 동시성과 데이터 일관성 사이에서 균형을 맞추기 위한 중요한 설정입니다. 애플리케이션의 요구 사항과 시스템 성능 목표에 따라 적절한 격리 수준을 선택하는 것이 중요합니다. 예를 들어, 금융 시스템처럼 높은 데이터 일관성이 요구되는 경우에는 <strong>Serializable</strong> 수준을 고려해볼 수 있으며, 반대로 높은 성능과 동시성이 중요한 경우에는 <strong>Read Committed</strong>나 <strong>Read Uncommitted</strong>를 선택할 수 있습니다.</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>다른 게시물 읽기</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://disj11.github.io/date-time-formatter-in-java/><span class=button__icon>←</span>
<span class=button__text>Date Time Formatter in Java</span>
</a></span><span class="button next"><a href=https://disj11.github.io/union-find/><span class=button__text>유니온 파인드</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>Life Log</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2024 Powered by <a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span><a href=https://github.com/panr/hugo-theme-hello-friend target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>