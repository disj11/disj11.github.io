<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kotlin on Life Log</title><link>https://disj11.github.io/tags/kotlin/</link><description>Recent content in kotlin on Life Log</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Tue, 10 Jan 2023 23:59:43 +0900</lastBuildDate><atom:link href="https://disj11.github.io/tags/kotlin/index.xml" rel="self" type="application/rss+xml"/><item><title>Kotlin: Memory Efficient Iterable Data Processing with Sequences</title><link>https://disj11.github.io/memory-efficient-iterable-data-processing-with-sequences/</link><pubDate>Tue, 10 Jan 2023 23:59:43 +0900</pubDate><guid>https://disj11.github.io/memory-efficient-iterable-data-processing-with-sequences/</guid><description>
Kotlin provides extension functions for the Iterable interface, such as the filter function. Here is an example of using the filter function:
fun averageNonBlankLength(strings: List&amp;lt;String&amp;gt;): Double = strings .filter { it.isNotBlank() } .map(String::length) .sum() / strings.size.toDouble() It&amp;rsquo;s worth noting that the filter and map functions in Kotlin return new Lists, unlike their counterparts Stream.filter and Stream.map in Java, which return a Stream. In this example, two new intermediate lists are created in memory as the result of calling filter and map on the original list.</description></item><item><title>Nullable Receiver in Extension Functions of Kotlin</title><link>https://disj11.github.io/nullable-receiver-in-extension-functions-of-kotlin/</link><pubDate>Sun, 08 Jan 2023 21:22:27 +0900</pubDate><guid>https://disj11.github.io/nullable-receiver-in-extension-functions-of-kotlin/</guid><description>
The receiver object in extension functions allows null values because it is actually a parameter. At first glance, anObject.method() and anObject.extensionFunction() may look similar, but this is not the case. If anObject is null, the method() will never be called, but the extensionFunction() can still be called. Here is an example:
fun String?.extensionFunction() = this?.length fun main() { val str: String? = null println(str.extensionFunction()) // prints &amp;#39;null&amp;#39; } In this example, when using this inside an extension function, note that the safe call operator should be used.</description></item><item><title>Notes on Using Data Classes in Kotlin</title><link>https://disj11.github.io/notes-on-using-data-classes-in-kotlin/</link><pubDate>Sun, 08 Jan 2023 14:39:00 +0900</pubDate><guid>https://disj11.github.io/notes-on-using-data-classes-in-kotlin/</guid><description>
When using data classes in Kotlin, it is important to keep a few things in mind. Data classes automatically create a copy() function, which can be used to create a new instance of the class with modified property values. However, if a property of the class must maintain an invariant, this function may not behave as expected.
For example, consider the following Point class:
data class Point private constructor( val value: Int, ) { companion object { fun of(value: Int) = if (value &amp;lt; 0) { throw IllegalArgumentException(&amp;#34;The value argument should always be set to a positive value, but the current value is $value&amp;#34;) } else { Point(value) } } } The value property of the Point class is intended to be positive.</description></item></channel></rss>