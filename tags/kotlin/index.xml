<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kotlin on</title><link>https://disj11.github.io/tags/kotlin/</link><description>Recent content in Kotlin on</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Thu, 22 Feb 2024 20:46:04 +0900</lastBuildDate><atom:link href="https://disj11.github.io/tags/kotlin/index.xml" rel="self" type="application/rss+xml"/><item><title>Ktlint: 기본 설정 변경 및 커스터마이징 가이드</title><link>https://disj11.github.io/editorconfig/</link><pubDate>Thu, 22 Feb 2024 20:46:04 +0900</pubDate><guid>https://disj11.github.io/editorconfig/</guid><description>
.editorconfig를 활용한 스타일 커스터마이징 방법을 알아봅니다. 특정 규칙 비활성화, IntelliJ 플러그인 사용법, 그리고 효율적인 코드 스타일 관리 팁을 제공합니다.</description></item><item><title>Kotlin: Memory Efficient Iterable Data Processing with Sequences</title><link>https://disj11.github.io/en/memory-efficient-iterable-data-processing-with-sequences/</link><pubDate>Tue, 10 Jan 2023 23:59:43 +0900</pubDate><guid>https://disj11.github.io/en/memory-efficient-iterable-data-processing-with-sequences/</guid><description>
Let's find out how do they differ in behavior between Iterable and Sequence in Kotlin.</description></item><item><title>효율적인 Kotlin 컬렉션 처리: Iterable과 Sequence의 차이점과 활용법</title><link>https://disj11.github.io/memory-efficient-iterable-data-processing-with-sequences/</link><pubDate>Tue, 10 Jan 2023 23:59:43 +0900</pubDate><guid>https://disj11.github.io/memory-efficient-iterable-data-processing-with-sequences/</guid><description>
Kotlin의 Iterable과 Sequence는 컬렉션을 처리하는 두 가지 주요 방식으로, 즉시 평가와 지연 평가라는 서로 다른 전략을 사용합니다. 이 글에서는 두 방식의 차이점, 성능 비교, 적합한 사용 사례를 중심으로 효율적인 Kotlin 코드를 작성하는 방법을 알아봅니다.</description></item><item><title>Kotlin: 확장 함수의 수신 객체</title><link>https://disj11.github.io/nullable-receiver-in-extension-functions-of-kotlin/</link><pubDate>Sun, 08 Jan 2023 21:22:27 +0900</pubDate><guid>https://disj11.github.io/nullable-receiver-in-extension-functions-of-kotlin/</guid><description>
확장 함수의 수신 객체는 null 값이 될 수 있다.</description></item><item><title>Nullable Receiver in Extension Functions of Kotlin</title><link>https://disj11.github.io/en/nullable-receiver-in-extension-functions-of-kotlin/</link><pubDate>Sun, 08 Jan 2023 21:22:27 +0900</pubDate><guid>https://disj11.github.io/en/nullable-receiver-in-extension-functions-of-kotlin/</guid><description>
The receiver object in extension functions allows null value.</description></item><item><title>Kotlin에서 데이터 클래스를 사용할 때 주의할 점</title><link>https://disj11.github.io/notes-on-using-data-classes-in-kotlin/</link><pubDate>Sun, 08 Jan 2023 14:39:00 +0900</pubDate><guid>https://disj11.github.io/notes-on-using-data-classes-in-kotlin/</guid><description>
&lt;p>Kotlin에서 데이터 클래스를 주의해야 할 사항이 있다.
데이터 클래스는 자동으로 copy() 함수를 생성하는데, 이 함수를 통해 속성값을 수정한 새로운 인스턴스를 생성할 수 있게 된다.
클래스의 속성 중에 불변성을 유지해야 하는 속성이 있다면, 데이터 클래스의 사용은 위험할 수 있다.&lt;/p></description></item><item><title>Notes on Using Data Classes in Kotlin</title><link>https://disj11.github.io/en/notes-on-using-data-classes-in-kotlin/</link><pubDate>Sun, 08 Jan 2023 14:39:00 +0900</pubDate><guid>https://disj11.github.io/en/notes-on-using-data-classes-in-kotlin/</guid><description>
Take note of the copy() function When using data classes in Kotlin</description></item></channel></rss>