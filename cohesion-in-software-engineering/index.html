<!doctype html><html lang=ko><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XD9VVSGMKV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XD9VVSGMKV")}</script><title>소프트웨어 응집도와 LCOM: 이해와 활용 ::
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" 응집 (Cohesion) # 응집은 소프트웨어 모듈 내 구성 요소들이 얼마나 밀접하게 연관되어 있는지를 나타내는 개념으로, 높은 응집도는 모듈의 독립성과 유지보수성을 높이는 데 기여합니다. 응집은 여러 유형으로 나뉘며, 각 유형은 모듈 내 구성 요소들의 관계와 협력 방식을 기준으로 정의됩니다. 아래에서는 각 응집 유형을 예시와 함께 설명합니다.
"><meta name=keywords content="개발 블로그,개발블로그"><meta name=robots content="noodp"><link rel=canonical href=https://disj11.github.io/cohesion-in-software-engineering/><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://disj11.github.io/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://disj11.github.io/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://disj11.github.io/img/favicon.png><link href=/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="소프트웨어 응집도와 LCOM: 이해와 활용"><meta name=twitter:description content="소프트웨어 설계의 핵심 개념인 **응집도(Cohesion)** 를 다양한 유형과 예시를 통해 쉽게 이해할 수 있도록 설명합니다. 또한, 클래스의 응집도를 정량적으로 평가하는 LCOM(Lack of Cohesion in Methods) 메트릭을 활용하여 설계 품질을 분석하고 개선하는 방법을 제시합니다."><meta property="og:url" content="https://disj11.github.io/cohesion-in-software-engineering/"><meta property="og:site_name" content="Life Log"><meta property="og:title" content="소프트웨어 응집도와 LCOM: 이해와 활용"><meta property="og:description" content="소프트웨어 설계의 핵심 개념인 **응집도(Cohesion)** 를 다양한 유형과 예시를 통해 쉽게 이해할 수 있도록 설명합니다. 또한, 클래스의 응집도를 정량적으로 평가하는 LCOM(Lack of Cohesion in Methods) 메트릭을 활용하여 설계 품질을 분석하고 개선하는 방법을 제시합니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-12T11:41:11+09:00"><meta property="article:modified_time" content="2024-12-29T18:15:00+09:00"><meta property="article:tag" content="Software Engineering"><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4.14.2/dist/algoliasearch-lite.umd.js integrity="sha256-dImjLPUsG/6p3+i7gVKBiDM8EemJAhQ0VvkRK2pVsQY=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@algolia/autocomplete-js></script><script>function initAutoComplete(){const e=document.createElement("div");e.id="autocomplete";const t=document.createElement("li");t.appendChild(e),document.querySelector("nav.menu > ul")?.prepend(t)}window.onload=()=>{initAutoComplete();const e=algoliasearch("XPOQNA4T7C","da59fb86972a7cc1eb6f3172adf593a8"),{autocomplete:t,getAlgoliaResults:n}=window["@algolia/autocomplete-js"];t({container:"#autocomplete",placeholder:"Search for posts",getSources({query:t}){return[{sourceId:"posts",getItems(){return n({searchClient:e,queries:[{indexName:"lifelog",query:t,params:{hitsPerPage:5,attributesToSnippet:["title:10","content:35"],snippetEllipsisText:"…"}}]})},templates:{header({html:e}){return e`
                                    <span class="aa-SourceHeaderTitle">Posts</span>
                                    <div class="aa-SourceHeaderLine"/>
                                `},item({item:e,components:n,html:s}){return s`
                                    <a class="aa-ItemLink" href="${e.href}?search=${t}">
                                        <div class="aa-ItemContent">
                                            <div class="aa-ItemContentBody">
                                                <div class="aa-ItemContentTitle">
                                                    ${n.Highlight({hit:e,attribute:"title"})}
                                                </div>
                                                <div class="aa-ItemContentDescription">
                                                    ${n.Snippet({hit:e,attribute:"content"})}
                                                </div>
                                            </div>
                                        </div>
                                    </a>
                                `},noResults(){return"No posts for this query."}}}]}})}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"]]}}</script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>Life Log</span>
<span class=logo__cursor></span>
</a><span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/notes>Notes</a></li><li><a href=/tags>Tags</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/notes>Notes</a></li><li><a href=/tags>Tags</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><article class=post><h1 class=post-title>소프트웨어 응집도와 LCOM: 이해와 활용</h1><div class=post-meta><time class=post-date>2023-03-12
</time><span class=post-moddate>(Modified:
2024-12-29)</span></div><span class=post-tags><a href=https://disj11.github.io/tags/software-engineering/>#software engineering</a>&nbsp;</span><div class=post-content><h2 id=응집-cohesion>응집 (Cohesion)
<a href=#%ec%9d%91%ec%a7%91-cohesion class=h-anchor aria-hidden=true>#</a></h2><p>응집은 소프트웨어 모듈 내 구성 요소들이 얼마나 밀접하게 연관되어 있는지를 나타내는 개념으로, <strong>높은 응집도</strong>는 모듈의 독립성과 유지보수성을 높이는 데 기여합니다. 응집은 여러 유형으로 나뉘며, 각 유형은 모듈 내 구성 요소들의 관계와 협력 방식을 기준으로 정의됩니다. 아래에서는 각 응집 유형을 <strong>예시와 함께</strong> 설명합니다.</p><h3 id=1-기능적-응집-functional-cohesion><strong>1. 기능적 응집 (Functional Cohesion)</strong>
<a href=#1-%ea%b8%b0%eb%8a%a5%ec%a0%81-%ec%9d%91%ec%a7%91-functional-cohesion class=h-anchor aria-hidden=true>#</a></h3><p>모듈 내 모든 구성 요소가 <strong>단일한 목적</strong>을 위해 협력하며, 특정 작업을 완벽히 수행하기 위해 필요한 모든 기능이 포함된 경우입니다. 이는 가장 이상적인 응집 형태로 간주됩니다.</p><ul><li><strong>예시</strong>:<br>계산기 프로그램에서 사각형의 넓이와 둘레를 계산하는 모듈은 입력값(가로, 세로)을 받아 넓이와 둘레를 계산한 후 결과를 반환합니다. 이 모듈은 단일 작업(사각형 계산)에 집중되어 있어 기능적 응집을 가집니다.</li></ul><h3 id=2-순차적-응집-sequential-cohesion><strong>2. 순차적 응집 (Sequential Cohesion)</strong>
<a href=#2-%ec%88%9c%ec%b0%a8%ec%a0%81-%ec%9d%91%ec%a7%91-sequential-cohesion class=h-anchor aria-hidden=true>#</a></h3><p>모듈 내 구성 요소들이 <strong>순차적으로 실행</strong>되며, 하나의 구성 요소 출력이 다음 구성 요소의 입력으로 사용되는 경우입니다.</p><ul><li><strong>예시</strong>:<br>데이터 처리 파이프라인을 생각해볼 수 있습니다. 예를 들어, 파일에서 데이터를 읽고 → 데이터를 정제하고 → 정제된 데이터를 데이터베이스에 저장하는 작업이 순서대로 이루어지는 모듈은 순차적 응집을 가집니다.</li></ul><h3 id=3-소통적-응집-communicational-cohesion><strong>3. 소통적 응집 (Communicational Cohesion)</strong>
<a href=#3-%ec%86%8c%ed%86%b5%ec%a0%81-%ec%9d%91%ec%a7%91-communicational-cohesion class=h-anchor aria-hidden=true>#</a></h3><p>모듈 내 구성 요소들이 <strong>공통 데이터</strong>를 사용하거나 동일한 데이터를 기반으로 작업하는 경우입니다.</p><ul><li><strong>예시</strong>:<br>고객의 장바구니 데이터를 처리하는 모듈에서는 장바구니 데이터를 기반으로 할인 계산, 배송비 계산, 세금 계산 등의 작업이 이루어질 수 있습니다. 이처럼 구성 요소들은 서로 다른 작업을 수행하지만, 동일한 데이터를 공유하며 협력합니다.</li></ul><h3 id=4-절차적-응집-procedural-cohesion><strong>4. 절차적 응집 (Procedural Cohesion)</strong>
<a href=#4-%ec%a0%88%ec%b0%a8%ec%a0%81-%ec%9d%91%ec%a7%91-procedural-cohesion class=h-anchor aria-hidden=true>#</a></h3><p>구성 요소들이 특정 절차나 <strong>순서를 따라 실행</strong>되도록 그룹화된 경우입니다. 이는 순차적 응집과 유사하지만, 반드시 동일한 데이터를 다루지 않을 수도 있습니다.</p><ul><li><strong>예시</strong>:<br>사용자 인증 모듈에서 사용자의 자격 증명을 확인하고 → 액세스 토큰을 생성하며 → 사용자 활동 로그를 업데이트하는 과정은 절차적 응집의 예입니다.</li></ul><h3 id=5-일시적-응집-temporal-cohesion><strong>5. 일시적 응집 (Temporal Cohesion)</strong>
<a href=#5-%ec%9d%bc%ec%8b%9c%ec%a0%81-%ec%9d%91%ec%a7%91-temporal-cohesion class=h-anchor aria-hidden=true>#</a></h3><p>모듈 내 구성 요소들이 특정 시간이나 이벤트에 따라 함께 실행되는 경우입니다.</p><ul><li><strong>예시</strong>:<br>시스템 초기화 시, 로그 파일 생성, 설정 파일 로드, 캐시 초기화 등 서로 연관성이 없어 보이는 작업들이 동시에 실행된다면 이는 일시적 응집에 해당합니다.</li></ul><h3 id=6-논리적-응집-logical-cohesion><strong>6. 논리적 응집 (Logical Cohesion)</strong>
<a href=#6-%eb%85%bc%eb%a6%ac%ec%a0%81-%ec%9d%91%ec%a7%91-logical-cohesion class=h-anchor aria-hidden=true>#</a></h3><p>구성 요소들이 기능적으로 연관되기보다는 <strong>논리적인 범주</strong>에 따라 그룹화된 경우입니다.</p><ul><li><strong>예시</strong>:<br>자바의 <code>StringUtils</code> 클래스처럼 문자열 관련 다양한 정적 메서드(문자열 대소문자 변환, 문자열 자르기 등)가 포함된 경우입니다. 이들은 논리적으로는 관련이 있지만, 기능적으로는 독립적입니다.</li></ul><h3 id=7-동시적-응집-coincidental-cohesion><strong>7. 동시적 응집 (Coincidental Cohesion)</strong>
<a href=#7-%eb%8f%99%ec%8b%9c%ec%a0%81-%ec%9d%91%ec%a7%91-coincidental-cohesion class=h-anchor aria-hidden=true>#</a></h3><p>모듈 내 구성 요소들이 단순히 같은 소스 파일에 포함되어 있을 뿐, 서로 아무런 연관성이 없는 경우입니다. 이는 가장 낮은 수준의 응집도로 간주됩니다.</p><ul><li><strong>예시</strong>:<br>한 모듈에 문자열 출력 함수와 리스트 정렬 함수가 함께 포함되어 있다면 이는 동시적 응집의 예로 볼 수 있습니다. 이러한 설계는 유지보수성과 재사용성을 저하시킵니다.</li></ul><hr><h2 id=lcom-lack-of-cohesion-in-methods>LCOM (Lack of Cohesion in Methods)
<a href=#lcom-lack-of-cohesion-in-methods class=h-anchor aria-hidden=true>#</a></h2><p>코드의 응집도를 정량적으로 평가하기 위해 LCOM(Lack of Cohesion in Methods) 메트릭을 사용할 수 있습니다. 이는 클래스 내 메서드들이 공유 필드를 얼마나 활용하는지 분석하여 응집도를 측정합니다.</p><h3 id=lcom-활용-예-클래스-x-y-z-비교>LCOM 활용 예: 클래스 X, Y, Z 비교
<a href=#lcom-%ed%99%9c%ec%9a%a9-%ec%98%88-%ed%81%b4%eb%9e%98%ec%8a%a4-x-y-z-%eb%b9%84%ea%b5%90 class=h-anchor aria-hidden=true>#</a></h3><p><img src=/images/LCOM.jpg alt="LCOM 메트릭"></p><p>이미지에 나타난 클래스 X, Y, Z는 LCOM(Lack of Cohesion in Methods, 메서드 간 응집 결여도)을 계산하고 이해하는 데 유용한 사례를 제공합니다. 각 클래스의 구조를 분석하여 응집도를 평가해보겠습니다.</p><h4 id=1-클래스-x><strong>1. 클래스 X</strong>
<a href=#1-%ed%81%b4%eb%9e%98%ec%8a%a4-x class=h-anchor aria-hidden=true>#</a></h4><ul><li><p><strong>구성</strong>:</p><ul><li>필드 A, B, C (육각형)</li><li>메서드 m1(), m2(), m3() (사각형)</li><li>각 메서드는 여러 필드를 공유하며 서로 연결되어 있습니다.</li></ul></li><li><p><strong>분석</strong>:<br>클래스 X는 모든 필드(A, B, C)가 여러 메서드(m1(), m2(), m3())에 의해 공유되고 사용됩니다. 이는 메서드와 필드가 서로 밀접하게 연관되어 있음을 나타냅니다.</p></li><li><p><strong>LCOM 평가</strong>:<br>LCOM 점수가 낮습니다(즉, 응집도가 높음). 이는 클래스가 단일한 목적을 가지고 있으며, 메서드들이 협력하여 작업을 수행한다는 것을 보여줍니다.</p></li></ul><h4 id=2-클래스-y><strong>2. 클래스 Y</strong>
<a href=#2-%ed%81%b4%eb%9e%98%ec%8a%a4-y class=h-anchor aria-hidden=true>#</a></h4><ul><li><p><strong>구성</strong>:</p><ul><li>필드 A, B, C</li><li>메서드 m1(), m2(), m3()</li><li>각 필드는 오직 하나의 메서드에서만 사용됩니다.</li></ul></li><li><p><strong>분석</strong>:<br>클래스 Y에서는 각 메서드가 특정 필드만 사용하며 다른 필드나 메서드와 상호작용하지 않습니다. 이는 메서드들이 독립적으로 작동한다는 것을 의미합니다.</p></li><li><p><strong>LCOM 평가</strong>:<br>LCOM 점수가 매우 높습니다(즉, 응집도가 낮음). 이 경우 클래스 Y는 단일 클래스로 유지할 필요가 없으며, 각 필드와 관련된 메서드를 별도의 클래스로 분리하는 것이 더 바람직합니다.</p></li></ul><h4 id=3-클래스-z><strong>3. 클래스 Z</strong>
<a href=#3-%ed%81%b4%eb%9e%98%ec%8a%a4-z class=h-anchor aria-hidden=true>#</a></h4><ul><li><p><strong>구성</strong>:</p><ul><li>필드 A, B, C</li><li>메서드 m1(), m2(), m3()</li><li>일부 메서드는 여러 필드를 공유하며 상호작용하지만, 특정 필드는 독립적으로 사용됩니다.</li></ul></li><li><p><strong>분석</strong>:<br>클래스 Z는 일부 메서드와 필드가 서로 연관되어 있지만, 다른 구성 요소들은 독립적으로 작동합니다. 이는 클래스 내에서 응집도가 부분적으로 유지되고 있음을 나타냅니다.</p></li><li><p><strong>LCOM 평가</strong>:<br>LCOM 점수는 중간 수준입니다. 독립적인 구성 요소(예: C와 관련된 m3())를 별도의 클래스로 분리하면 응집도를 향상시킬 수 있습니다.</p></li></ul><h4 id=결론><strong>결론</strong>
<a href=#%ea%b2%b0%eb%a1%a0 class=h-anchor aria-hidden=true>#</a></h4><ul><li><strong>클래스 X</strong>는 높은 응집도를 가지며 잘 설계된 구조입니다.</li><li><strong>클래스 Y</strong>는 낮은 응집도를 가지며, 리팩토링을 통해 각 필드와 관련된 메서드를 별도의 클래스로 분리하는 것이 적합합니다.</li><li><strong>클래스 Z</strong>는 부분적으로 응집되어 있으며, 독립적인 구성 요소를 분리하여 개선할 여지가 있습니다.</li></ul><p>이처럼 LCOM 분석은 클래스의 구조적 결함을 식별하고 설계를 개선하는 데 유용한 도구로 활용될 수 있습니다.</p><hr><h2 id=결론-1>결론
<a href=#%ea%b2%b0%eb%a1%a0-1 class=h-anchor aria-hidden=true>#</a></h2><p>응집도는 소프트웨어 설계 품질을 평가하는 중요한 척도이며, 높은 응집도를 유지하는 것이 바람직합니다. 각 유형의 응집을 이해하고 이를 설계에 적용함으로써 더 나은 모듈화와 유지보수성을 달성할 수 있습니다.</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>다른 게시물 읽기</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://disj11.github.io/distance-from-the-main-sequence/><span class=button__icon>←</span>
<span class=button__text>메인 시퀀스로부터의 거리: 추상도와 불안정도를 활용한 아키텍처 평가</span>
</a></span><span class="button next"><a href=https://disj11.github.io/what-you-need-to-know-first-for-scalability/><span class=button__text>확장성과 성능 최적화: 시스템 부하와 효율적인 대처 전략</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>Life Log</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span><a href=https://github.com/panr/hugo-theme-hello-friend target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>